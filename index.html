<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>随机国家生成器（豪华版 - 增强版）</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
        }

        body {
            background: linear-gradient(135deg, #dfe5ff, #f8fbff);
            min-height: 100vh;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 280px;
            padding: 20px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.45);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.08);
            margin: 10px;
        }

        .main {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(255, 255, 255, 0.45);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.08);
            margin: 10px;
        }

        .sidebar input,
        .sidebar select {
            width: 100%;
            padding: 10px 14px;
            border-radius: 14px;
            border: none;
            margin-top: 6px;
            margin-bottom: 16px;
            background: rgba(255,255,255,0.8);
        }

        .sidebar button {
            width: 100%;
            padding: 14px;
            margin-top: 12px;
            border: none;
            border-radius: 15px;
            background: #3d6bff;
            color: white;
            font-size: 15px;
            cursor: pointer;
            transition: 0.2s;
        }

        .sidebar button:hover {
            opacity: 0.85;
        }

        #mapCanvas {
            border-radius: 20px;
            max-width: 95%;
            max-height: 95%;
        }

        .report {
            position: fixed;
            right: 20px;
            bottom: 20px;
            width: 420px;
            max-height: 500px;
            padding: 20px;
            overflow-y: auto;
            display: none;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.08);
        }

        h2, h3 {
            margin-bottom: 10px;
        }

        label {
            font-weight: 600;
            display: block;
            margin-top: 10px;
        }

        hr {
            margin: 20px 0;
            border: none;
            border-top: 1px solid rgba(0,0,0,0.1);
        }
    </style>

</head>
<body>

<div class="container">
    <aside class="sidebar">
        <h2>国家生成器</h2>

        <label>国家名称</label>
        <input id="nationName" type="text" placeholder="例如：Shawnland">

        <label>地图尺寸</label>
        <select id="mapSize">
            <option value="1024">1024 × 1024（超清）</option>
            <option value="800" selected>800 × 800（高品质）</option>
            <option value="600">600 × 600（标准）</option>
        </select>

        <button id="generateBtn">生成国家</button>
        <button id="regenBtn">重新生成地图</button>
        <button id="reportBtn">生成报告</button>
        <button id="saveBtn">保存为 PNG</button>

        <hr>

        <h3>国家信息</h3>
        <div id="nationInfo">点击"生成国家"开始</div>
    </aside>

    <main class="main">
        <canvas id="mapCanvas"></canvas>
    </main>

</div>

<div id="reportBox" class="report"></div>

<script>
/******************************************************
 * 随机国家生成器 - 完整连接版 (增强版)
 ******************************************************/

let canvas = document.getElementById("mapCanvas");
let ctx = canvas.getContext("2d");

let mapSize = 800;
let heightMap = [];
let tempMap = [];
let rivers = [];
let cities = [];
let forests = [];
let roads = [];

const SEA_LEVEL_THRESHOLD = 0.02;

let nationData = {
    name: "",
    population: 0,
    area: 0,
    forestCover: 0,
    roadLength: 0,
    capital: null
};

/******************************************************
 * 陆地验证
 ******************************************************/
function isLand(x, y) {
    if (x < 0 || y < 0 || x >= mapSize || y >= mapSize) return false;
    return heightMap[y] && heightMap[y][x] >= SEA_LEVEL_THRESHOLD;
}

/******************************************************
 * Perlin Noise (保持不变)
 ******************************************************/
let permutation = [];
for (let i = 0; i < 256; i++) permutation[i] = i;
for (let i = 255; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1));
    [permutation[i], permutation[j]] = [permutation[j], permutation[i]];
}
let p = [...permutation, ...permutation];

function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
function lerp(t, a, b) { return a + t * (b - a); }
function grad(hash, x, y) {
    switch (hash & 3) {
        case 0: return x + y;
        case 1: return -x + y;
        case 2: return x - y;
        case 3: return -x - y;
    }
}
function perlin(x, y) {
    let X = Math.floor(x) & 255;
    let Y = Math.floor(y) & 255;
    x -= Math.floor(x);
    y -= Math.floor(y);
    let u = fade(x);
    let v = fade(y);
    let A = p[X] + Y;
    let B = p[X + 1] + Y;
    return lerp(v,
        lerp(u, grad(p[A], x, y), grad(p[B], x - 1, y)),
        lerp(u, grad(p[A + 1], x, y - 1), grad(p[B + 1], x - 1, y - 1))
    );
}

/******************************************************
 * 生成高度图 (保持不变)
 ******************************************************/
function generateHeightMap() {
    heightMap = [];
    tempMap = [];

    for (let y = 0; y < mapSize; y++) {
        heightMap[y] = [];
        tempMap[y] = [];
        for (let x = 0; x < mapSize; x++) {
            let nx = x / mapSize - 0.5;
            let ny = y / mapSize - 0.5;
            let e = 1.00 * perlin(nx * 3, ny * 3) +
                    0.50 * perlin(nx * 6, ny * 6) +
                    0.25 * perlin(nx * 12, ny * 12);
            e = (e + 1) / 2;
            let dist = Math.sqrt(nx * nx + ny * ny);
            e = e - dist * 1.1;
            heightMap[y][x] = e;
            let t = 1 - Math.abs((y / mapSize) - 0.5) * 2;
            tempMap[y][x] = t;
        }
    }
}

/******************************************************
 * 生物群系颜色 (保持不变)
 ******************************************************/
function biomeColor(h, t) {
    if (h < SEA_LEVEL_THRESHOLD) return "#3fa0ff";
    if (h < 0.05) {
        if (t < 0.33) return "#cfe0d8";
        if (t < 0.66) return "#8dd17d";
        return "#5cd167";
    }
    if (h < 0.20) {
        if (t < 0.33) return "#4d7c3b";
        if (t < 0.66) return "#6dad5f";
        return "#3aa549";
    }
    if (h < 0.35) return "#b5946d";
    return "#ffffff";
}

/******************************************************
 * 渲染地图 (保持不变)
 ******************************************************/
function renderMap() {
    for (let y = 0; y < mapSize; y++) {
        for (let x = 0; x < mapSize; x++) {
            let h = heightMap[y][x];
            let t = tempMap[y][x];
            ctx.fillStyle = biomeColor(h, t);
            ctx.fillRect(x, y, 1, 1);
        }
    }
}

/******************************************************
 * 河流 (保持不变)
 ******************************************************/
function generateRivers() {
    rivers = [];
    for (let i = 0; i < 7; i++) {
        let x = Math.floor(Math.random() * mapSize);
        let y = Math.floor(Math.random() * mapSize);
        if (heightMap[y][x] < 0.15) continue;
        let river = [];
        for (let j = 0; j < 900; j++) {
            river.push({ x, y });
            let bestX = x, bestY = y;
            let bestH = heightMap[y][x];
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    let nx = x + dx;
                    let ny = y + dy;
                    if (nx < 0 || ny < 0 || nx >= mapSize || ny >= mapSize) continue;
                    let nh = heightMap[ny][nx];
                    if (nh < bestH) {
                        bestH = nh;
                        bestX = nx;
                        bestY = ny;
                    }
                }
            }
            x = bestX;
            y = bestY;
            if (heightMap[y][x] < SEA_LEVEL_THRESHOLD) break;
        }
        rivers.push(river);
    }
}

function drawRivers() {
    ctx.strokeStyle = "#2f76ff";
    ctx.lineWidth = 2;
    rivers.forEach(r => {
        ctx.beginPath();
        ctx.moveTo(r[0].x, r[0].y);
        r.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.stroke();
    });
}

/******************************************************
 * 城市评分 & 城市生成 (保持不变)
 ******************************************************/
function calculateCityScore(x, y) {
    let score = 0;
    let h = heightMap[y][x];
    if (h >= SEA_LEVEL_THRESHOLD && h < 0.10) score += 50;
    else if (h < 0.20) score += 30;
    else if (h < 0.30) score += 10;
    
    let nearSea = false;
    let seaDistance = Infinity;
    for (let dy = -15; dy <= 15; dy++) {
        for (let dx = -15; dx <= 15; dx++) {
            let nx = x + dx, ny = y + dy;
            if (nx < 0 || ny < 0 || nx >= mapSize || ny >= mapSize) continue;
            if (heightMap[ny][nx] < SEA_LEVEL_THRESHOLD) {
                nearSea = true;
                let dist = Math.sqrt(dx*dx + dy*dy);
                seaDistance = Math.min(seaDistance, dist);
            }
        }
    }
    if (nearSea) {
        score += 40 + Math.max(0, 20 - seaDistance);
    }
    
    let nearRiver = false;
    rivers.forEach(r => {
        r.forEach(p => {
            let dist = Math.sqrt((p.x - x)**2 + (p.y - y)**2);
            if (dist < 10) nearRiver = true;
        });
    });
    if (nearRiver) score += 30;
    
    return score;
}

function generateCities() {
    cities = [];
    for (let i = 0; i < 15; i++) {
        let bestScore = -1;
        let bestCity = null;
        for (let attempt = 0; attempt < 500; attempt++) {
            let x = Math.floor(Math.random() * mapSize);
            let y = Math.floor(Math.random() * mapSize);
            if (!isLand(x, y)) continue;
            let h = heightMap[y][x];
            if (h > 0.25) continue;
            let tooClose = cities.some(c => Math.sqrt((c.x - x)**2 + (c.y - y)**2) < 30);
            if (tooClose) continue;
            let score = calculateCityScore(x, y);
            if (score > bestScore) {
                bestScore = score;
                bestCity = { x, y, score };
            }
        }
        if (bestCity) cities.push(bestCity);
    }
    cities.forEach(c => {
        c.size = Math.min(1, c.score / 150);
    });
}

function drawCities() {
    cities.forEach((c, index) => {
        if (index === 0) {
            ctx.fillStyle = "#ff0000";
            ctx.strokeStyle = "#ffffff";
            ctx.lineWidth = 3;
            let size = 12;
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                let angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                let x = c.x + size * Math.cos(angle);
                let y = c.y + size * Math.sin(angle);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        } else {
            ctx.fillStyle = c.size > 0.75 ? "#ff4f4f" :
                            c.size > 0.45 ? "#ff8d3c" : "#ffd93c";
            ctx.strokeStyle = "#ffffff";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(c.x, c.y, 4 + c.size * 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
        }
    });
}

/******************************************************
 * 森林 (保持不变)
 ******************************************************/
function generateForests() {
    forests = [];
    for (let y = 0; y < mapSize; y += 3) {
        for (let x = 0; x < mapSize; x += 3) {
            let h = heightMap[y][x];
            if (h > 0.05 && h < 0.20 && Math.random() < 0.15) {
                forests.push({ x, y });
            }
        }
    }
}

function drawForests() {
    ctx.fillStyle = "#2b6122";
    forests.forEach(f => ctx.fillRect(f.x, f.y, 2, 2));
}

/******************************************************
 * 增强的道路生成算法 - 允许桥梁
 ******************************************************/
function generateRoads() {
    roads = [];
    if (cities.length === 0) return;
    
    const capital = cities[0];
    nationData.capital = capital;
    
    // 为每个城市生成道路
    for (let i = 1; i < cities.length; i++) {
        const city = cities[i];
        const path = findBestPath(city, capital);
        
        if (path && path.length > 0) {
            roads.push({
                path: path,
                from: city,
                to: capital,
                success: true
            });
            // console.log(`✓ 城市${i}连接成功，路径长度: ${path.length}`);
        } else {
            roads.push({
                path: [],
                from: city,
                to: capital,
                success: false
            });
            // console.log(`✗ 城市${i}连接失败`);
        }
    }
}

// 改进的寻路算法 - 允许跨越水域 (桥梁)
function findBestPath(start, end) {
    // 队列中的元素包含：x, y, path数组
    const queue = [{x: start.x, y: start.y, path: [{x: start.x, y: start.y, isBridge: false}]}];
    const visited = new Set();
    visited.add(`${start.x},${start.y}`);
    
    const stepSize = 2; // 每次移动2像素
    const maxIterations = 100000; // 增加迭代次数以提高连通性
    let iterations = 0;
    
    while (queue.length > 0 && iterations < maxIterations) {
        iterations++;
        const current = queue.shift();
        
        // 到达目标
        if (Math.abs(current.x - end.x) < 10 && Math.abs(current.y - end.y) < 10) {
            // 添加最后几步直接到达首都
            const finalPath = [...current.path];
            let x = current.x;
            let y = current.y;
            while (Math.abs(x - end.x) > 1 || Math.abs(y - end.y) > 1) {
                x += Math.sign(end.x - x);
                y += Math.sign(end.y - y);
                if (x >= 0 && y >= 0 && x < mapSize && y < mapSize) {
                    finalPath.push({x, y, isBridge: !isLand(x,y)});
                }
            }
            return simplifyPath(finalPath);
        }
        
        // 8个方向探索
        const directions = [
            {dx: -stepSize, dy: -stepSize}, {dx: 0, dy: -stepSize}, {dx: stepSize, dy: -stepSize},
            {dx: -stepSize, dy: 0},                                  {dx: stepSize, dy: 0},
            {dx: -stepSize, dy: stepSize},  {dx: 0, dy: stepSize},  {dx: stepSize, dy: stepSize}
        ];
        
        // 按照接近目标的顺序排序方向（启发式）
        directions.sort((a, b) => {
            const distA = Math.abs((current.x + a.dx) - end.x) + Math.abs((current.y + a.dy) - end.y);
            const distB = Math.abs((current.x + b.dx) - end.x) + Math.abs((current.y + b.dy) - end.y);
            return distA - distB;
        });
        
        for (const dir of directions) {
            const nx = current.x + dir.dx;
            const ny = current.y + dir.dy;
            const key = `${nx},${ny}`;
            
            // 检查边界
            if (nx < 0 || ny < 0 || nx >= mapSize || ny >= mapSize) continue;
            if (visited.has(key)) continue;
            
            const h = heightMap[ny][nx];
            let isBridgePoint = false;

            if (h < SEA_LEVEL_THRESHOLD) {
                // 如果是水域，检查它是否为浅水区或河流（即：不位于深海）
                // 允许短距离跨越水域，作为桥梁
                
                // 简单水域检查：不允许在大面积深海中移动。
                // 检查周围一小块区域的平均高度
                let avgH = 0;
                let count = 0;
                for(let dy=-1; dy<=1; dy++) {
                    for(let dx=-stepSize; dx<=stepSize; dx++) {
                        if (ny+dy >= 0 && nx+dx >= 0 && ny+dy < mapSize && nx+dx < mapSize) {
                            avgH += heightMap[ny+dy][nx+dx];
                            count++;
                        }
                    }
                }
                // 如果周围平均高度非常低（深海），则不允许通过
                if (avgH / count < SEA_LEVEL_THRESHOLD * 0.5) { 
                    continue;
                }
                isBridgePoint = true;
            }
            
            visited.add(key);
            queue.push({
                x: nx,
                y: ny,
                path: [...current.path, {x: nx, y: ny, isBridge: isBridgePoint}]
            });
        }
    }
    
    // console.log(`寻路失败，迭代: ${iterations}`);
    return null;
}

// 简化路径，减少点数并保留 isBridge 标记
function simplifyPath(path) {
    if (path.length < 3) return path;
    
    const simplified = [path[0]];
    for (let i = 1; i < path.length - 1; i++) {
        // 如果是桥梁点，一定要保留，避免桥梁路段被优化掉
        if (path[i].isBridge || i % 3 === 0) { 
            simplified.push(path[i]);
        }
    }
    simplified.push(path[path.length - 1]);
    return simplified;
}

/******************************************************
 * 渲染道路和桥梁
 ******************************************************/
function drawRoads() {
    ctx.lineWidth = 3;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    
    roads.forEach((road) => {
        if (!road.success || road.path.length === 0) return;
        
        // 步骤 1: 绘制道路主体 (白色描边和黑色主体)
        
        // 白色描边
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(road.path[0].x, road.path[0].y);
        road.path.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.stroke();
        
        // 黑色主体
        ctx.strokeStyle = "#333333";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(road.path[0].x, road.path[0].y);
        road.path.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.stroke();

        // 步骤 2: 绘制桥梁标记
        
        let startBridge = null;
        for (let i = 0; i < road.path.length; i++) {
            const p = road.path[i];
            
            if (p.isBridge && startBridge === null) {
                // 桥梁路段开始
                startBridge = p;
            } else if (!p.isBridge && startBridge !== null) {
                // 桥梁路段结束，绘制桥梁标记
                ctx.strokeStyle = "#0000ff"; // 桥梁标记颜色 (蓝色)
                ctx.lineWidth = 1; 

                ctx.beginPath();
                ctx.moveTo(startBridge.x, startBridge.y);
                ctx.lineTo(road.path[i-1].x, road.path[i-1].y);
                ctx.stroke();
                
                // 在桥梁中央添加一个更明显的标记
                let midX = (startBridge.x + road.path[i-1].x) / 2;
                let midY = (startBridge.y + road.path[i-1].y) / 2;
                ctx.fillStyle = "#0000ff";
                ctx.beginPath();
                ctx.arc(midX, midY, 3, 0, Math.PI * 2);
                ctx.fill();
                
                startBridge = null;
            }
        }
        // 处理路径末尾的桥梁路段
        if (startBridge !== null) {
            ctx.strokeStyle = "#0000ff";
            ctx.lineWidth = 1;

            ctx.beginPath();
            ctx.moveTo(startBridge.x, startBridge.y);
            ctx.lineTo(road.path[road.path.length - 1].x, road.path[road.path.length - 1].y);
            ctx.stroke();

            let midX = (startBridge.x + road.path[road.path.length - 1].x) / 2;
            let midY = (startBridge.y + road.path[road.path.length - 1].y) / 2;
            ctx.fillStyle = "#0000ff";
            ctx.beginPath();
            ctx.arc(midX, midY, 3, 0, Math.PI * 2);
            ctx.fill();
        }
    });
}

/******************************************************
 * 报告 (保持不变)
 ******************************************************/
function generateReport() {
    const successfulRoads = roads.filter(r => r.success).length;
    const totalRoads = cities.length - 1;
    const connectivity = totalRoads > 0 ? (successfulRoads / totalRoads * 100).toFixed(1) : 0;
    
    let box = document.getElementById("reportBox");
    box.innerHTML = `
        <h2>${nationData.name}</h2>
        <p><b>人口：</b>${nationData.population.toLocaleString()}</p>
        <p><b>面积：</b>${nationData.area} km²</p>
        <p><b>森林覆盖率：</b>${(nationData.forestCover * 100).toFixed(1)}%</p>
        <p><b>道路总长度：</b>${nationData.roadLength.toFixed(1)} km</p>
        <p><b>城市数量：</b>${cities.length} 座</p>
        <p><b>道路连接数：</b>${successfulRoads}/${totalRoads} 条</p>
        <p><b>交通连通率：</b>${connectivity}%</p>
        <hr>
        <h3>城市等级</h3>
        <p><b>首都：</b>1 座</p>
        <p><b>大城市：</b>${cities.filter(c => c.size > 0.75 && c !== nationData.capital).length} 座</p>
        <p><b>中等城市：</b>${cities.filter(c => c.size > 0.45 && c.size <= 0.75).length} 座</p>
        <p><b>小城市：</b>${cities.filter(c => c.size <= 0.45).length} 座</p>
        <hr>
        <h3>发展分析</h3>
        <p>该国拥有多样生物群系，气候带宽，适合农业与港口产业发展。</p>
        ${connectivity < 100 ? '<p style="color: #ff6b6b;">仍有部分城市因地形隔绝或距离遥远而无法连接到首都。</p>' : '<p style="color: #51cf66;">所有城市均已成功连接到首都！</p>'}
    `;
    box.style.display = "block";
}

/******************************************************
 * 主流程 (保持不变)
 ******************************************************/
function generateMap() {
    console.log("=== 开始生成地图 ===");
    
    mapSize = Number(document.getElementById("mapSize").value);
    canvas.width = mapSize;
    canvas.height = mapSize;

    generateHeightMap();
    renderMap();
    generateRivers();
    drawRivers();
    generateForests();
    drawForests();
    generateCities();
    generateRoads(); // 增强后的道路生成
    drawRoads();     // 增强后的道路和桥梁渲染
    drawCities();    // 最后渲染城市，确保它们在道路上方

    nationData.name = document.getElementById("nationName").value || "未命名国家";
    nationData.population = Math.floor((cities.length * 200000) + Math.random() * 5_000_000);
    nationData.area = Math.floor(mapSize * mapSize / 1000);
    nationData.forestCover = forests.length / (mapSize * mapSize / 9);
    
    let totalRoadLength = 0;
    roads.forEach(r => {
        if (r.success) totalRoadLength += r.path.length;
    });
    nationData.roadLength = totalRoadLength * 0.1;
    
    const successfulRoads = roads.filter(r => r.success).length;
    
    let infoDiv = document.getElementById("nationInfo");
    infoDiv.innerHTML = `
        <p><b>名称：</b>${nationData.name}</p>
        <p><b>人口：</b>${nationData.population.toLocaleString()}</p>
        <p><b>城市：</b>${cities.length} 座</p>
        <p><b>已连接：</b>${successfulRoads}/${cities.length - 1} 条</p>
        <p style="color: ${successfulRoads === cities.length - 1 ? '#51cf66' : '#ff6b6b'};">
            <b>连通率：</b>${((successfulRoads / Math.max(1, cities.length - 1)) * 100).toFixed(1)}%
        </p>
    `;
    
    console.log("=== 地图生成完成！ ===");
}

/******************************************************
 * 保存 PNG (保持不变)
 ******************************************************/
function savePNG() {
    let link = document.createElement("a");
    link.download = `${nationData.name}.png`;
    link.href = canvas.toDataURL("image/png");
    link.click();
}

/******************************************************
 * 事件绑定 (保持不变)
 ******************************************************/
document.getElementById("generateBtn").addEventListener("click", generateMap);
document.getElementById("regenBtn").addEventListener("click", generateMap);
document.getElementById("reportBtn").addEventListener("click", generateReport);
document.getElementById("saveBtn").addEventListener("click", savePNG);

// 首次加载时运行一次
generateMap();
console.log("✓ 国家生成器已加载完成！");
</script>

</body>
</html>
